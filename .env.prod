# Environment Configuration Example
# Copy this file to .env and update with your actual values

# Node Environment
NODE_ENV=development

# Database Configuration
#DATABASE_URL=postgresql://rgpapp:r9pAdmin7@host.docker.internal:5432/rgpdb
POSTGRES_USER=postgres
POSTGRES_PASSWORD=r9pp9m!n
POSTGRES_DB=rgpdb

# Database Host Configuration
# For development with external DB: host.docker.internal
# For production with docker postgres: postgres
DB_HOST=209.182.234.84
DB_PORT=5432

# Logging
LOG_SQL=true

# File Upload Configuration
FILEUPLOAD_LOCATION=/app/upload
FILEUPOAD_SIZE_LIMIT=512000

# JWT Configuration
# e.g., use a strong random string
JWT_KEY=dev
JWT_EXPIRES=24h

# API Configuration
API_PORT=3000

# Frontend Configuration
FRONTEND_PORT=8000

# Volume Configuration
UPLOADS_PATH=~/uploads

# PostgreSQL Performance Tuning
# Adjust these values based on your system's available RAM
# Rule of thumb: Allocate 25% of system RAM to PostgreSQL

# shared_buffers: RAM used by PostgreSQL for caching (25% of RAM, max 8GB)
PG_SHARED_BUFFERS=256MB

# effective_cache_size: Estimate of OS and PostgreSQL cache (50-75% of RAM)
PG_EFFECTIVE_CACHE_SIZE=1GB

# work_mem: RAM per operation (sort, hash join) - increase for complex queries
# Formula: (Total RAM - shared_buffers) / (max_connections * 3)
PG_WORK_MEM=16MB

# maintenance_work_mem: RAM for VACUUM, CREATE INDEX operations
PG_MAINTENANCE_WORK_MEM=128MB

# max_connections: Maximum concurrent connections
PG_MAX_CONNECTIONS=100

# random_page_cost: Lower for SSD (1.1), higher for HDD (4.0)
PG_RANDOM_PAGE_COST=1.1

# effective_io_concurrency: Number of concurrent disk I/O operations (SSD: 200, HDD: 2)
PG_EFFECTIVE_IO_CONCURRENCY=200

# wal_buffers: Write-Ahead Log buffer size
PG_WAL_BUFFERS=16MB

# WAL size management for checkpoints
PG_MIN_WAL_SIZE=1GB
PG_MAX_WAL_SIZE=4GB

# checkpoint_completion_target: Spread checkpoint I/O (0.5-0.9)
PG_CHECKPOINT_COMPLETION_TARGET=0.9

# Log queries slower than this (milliseconds) - Production: 5000ms, Dev: 3000ms
PG_LOG_SLOW_QUERIES=5000
